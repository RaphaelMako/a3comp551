
###
## This file loads all our project data for reference.
###

import pickle
with open("data/images_l.pkl", 'rb') as f: labeled_images = pickle.load(f)
with open("data/labels_l.pkl", 'rb') as f: labels = pickle.load(f)
with open("data/images_ul.pkl", 'rb') as f: unlabeled_images = pickle.load(f)
with open("data/images_test.pkl", 'rb') as f: images_test = pickle.load(f)

import numpy as np

label_dict = {}
for letter in range(0, 26):
    for number in range(0, 10):
        label = str(number) + chr(65 + letter)
        label_dict[letter*10 + number] = label

# Get the unique integer for a given label (used by the pytorch CNN architecture.)
def label_to_int(label):
    key_list = list(label_dict.keys())
    value_list = list(label_dict.values())
    key_index = value_list.index(label)
    return key_list[key_index]

# Get the label that corresponds with the given integer (must be between 0 and 259 inclusive.)
def int_to_label(int):
    return label_dict[int]

# The dataset of labels, as unique integers (i.e., size == 30,000)
def integer_labels():
    return arrmap(label_to_int, arrmap(binary_to_nl, labels))

# Shortcut function that maps a numpy array to a numpy array using the given lambda (fn.)
# I didn't want to keep writing this, though there is probably a better way to implement it... :/
def arrmap(fn, arr: np.array):
    return np.array(list(map(fn, arr)))
# Shortcut function that maps a numpy array to a numpy array using the given lambda (fn.)
# I didn't want to keep writing this, though there is probably a better way to implement it... :/
def arrmap(fn, arr: np.array):
    return np.array(list(map(fn, arr)))

# Converts a single label into NUMBER/LETTER form.
# e.g., '[0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]' --> '9D'
def binary_to_nl(binary_label):
    num = None
    letter = None
    for i in range(0, len(binary_label)):
        entry = binary_label[i]
        if i <= 9 and entry == 1:
            num = i
        elif entry == 1:
            letter = chr(64 - 9 + i)
    return str(num) + letter

# Uniquely converts a single number/letter label into an integer.
# Each number 0-9 is mapped to 000, 100, 200, etc., and the letter index of a-z, mapped as 1-26 is added to it.
# e.g., "7C" --> "702"
def nl_to_int(ln_label):
    num = ln_label[0]
    letter = ln_label[1]
    return int(num) * 100 + (ord(letter) - 65)

# Converts back from a unique integer generated by the nl_to_int method into a number/letter label representation
def int_to_nl(int_label):
    num = 0
    for i in range(0, 10):
        if i * 100 <= int_label:
            num = i
    letter = None
    for i in range(0, 26):
        if (int_label - i) % 100 == 0:
            letter = chr(65 + i)
    return str(num) + letter

# Converts binary to integer labels
def labels_as_unique_integers():
    return arrmap(nl_to_int, arrmap(binary_to_nl, labels))